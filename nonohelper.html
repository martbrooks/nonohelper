<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Nonogram Scratchpad</title>

<style>
  :root {
    --cell-size: 22px;
    --grid-font: system-ui, -apple-system, "Segoe UI", sans-serif;
    --grid-bg: rgb(218,210,192);
    --dark-bg: rgb(29,31,33);
  }

  body {
    font-family: var(--grid-font);
    max-width: 1000px;
    margin: 20px auto;
    padding: 0 16px 40px;
    background: var(--dark-bg);
    color: #eee;
    transition: background 0.15s ease, color 0.15s ease;
  }

  body[data-theme="light"] {
    background: #f4f4f8;
    color: #222;
  }

  h1 {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
  }

  /* Controls */

  .top-bar {
    display: flex;
    justify-content: space-between;
    gap: 16px;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 8px;
  }

  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
  }

  .controls label {
    font-size: 0.95rem;
  }

  .controls input[type="number"] {
    width: 70px;
    padding: 3px 6px;
  }

  .theme-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
  }

  .theme-toggle label {
    cursor: pointer;
  }

  button {
    padding: 6px 12px;
    border-radius: 6px;
    border: 1px solid #666;
    background: #333;
    color: #f5f5f5;
    cursor: pointer;
    font-size: 0.95rem;
    transition: background 0.1s ease, filter 0.1s ease, border-color 0.1s ease;
  }

  button:hover {
    filter: brightness(1.1);
  }

  body[data-theme="light"] button {
    background: #f4f4f4;
    color: #222;
    border-color: #bbb;
  }

  .mode-select {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-bottom: 16px;
    font-size: 0.9rem;
  }

  .mode-select label {
    cursor: pointer;
  }

  /* Board */

  .board-wrapper {
    overflow: visible;
    max-height: none;
  }

  .board {
    display: flex;
    flex-direction: column;
    gap: 4px;
    user-select: none;
    transform-origin: top left;
  }

  .top-row,
  .bottom-row {
    display: flex;
    align-items: flex-start;
    gap: 4px;
  }

  .middle-row {
    display: flex;
    align-items: flex-start;
    gap: 4px;
  }

  .corner {
    width: var(--cell-size);
    height: var(--cell-size);
  }

  .number-row {
    display: grid;
  }

  .number-col {
    display: grid;
  }

  .number-row > div,
  .number-col > div {
    font-size: 12px;
    text-align: center;
    line-height: var(--cell-size);
    width: var(--cell-size);
    height: var(--cell-size);
    color: #ccc;
  }

  body[data-theme="light"] .number-row > div,
  body[data-theme="light"] .number-col > div {
    color: #444;
  }

  .grid {
    display: grid;
  }

  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    box-sizing: border-box;
    border: 1px solid #000;   /* uniform thin grid lines */
    background: var(--grid-bg);
    font-size: 16px;
    line-height: var(--cell-size);
    text-align: center;
    cursor: pointer;
    position: relative;
    box-shadow: none;         /* per-cell shadows are applied inline */
  }

  .cell.filled {
    background: #000;
    color: #000;
  }

  .cell.cross {
    background: var(--grid-bg);
  }

  .cell.cross::after {
    content: "Ã—";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 20px;
    font-weight: bold;
    line-height: 1;
    color: #c00;
    pointer-events: none;
  }

  /* Tooltip */

  .selection-tooltip {
    position: fixed;
    padding: 2px 6px;
    font-size: 11px;
    background: rgba(0, 0, 0, 0.8);
    color: #fff;
    border-radius: 4px;
    pointer-events: none;
    z-index: 1000;
    display: none;
  }
</style>
</head>
<body data-theme="dark">

<h1>Nonogram Scratchpad</h1>

<div class="top-bar">
  <div class="controls">
    <label>
      Columns (width):
      <input type="number" id="colsInput" min="5" max="50" step="5" value="25">
    </label>
    <label>
      Rows (height):
      <input type="number" id="rowsInput" min="5" max="50" step="5" value="25">
    </label>
    <button id="buildGridBtn">Create / reset grid</button>
  </div>

  <div class="theme-toggle">
    <span>Theme:</span>
    <label><input type="radio" name="theme" value="dark" checked> Dark</label>
    <label><input type="radio" name="theme" value="light"> Light</label>
  </div>
</div>

<div class="mode-select">
  <span>Selection mode:</span>
  <label><input type="radio" name="mode" value="line"> Straight line</label>
  <label><input type="radio" name="mode" value="rect" checked> Rectangle</label>
  <label><input type="radio" name="mode" value="free"> Freestyle</label>
</div>

<div class="board-wrapper" id="boardWrapper">
  <div class="board" id="boardRoot">

    <div class="top-row">
      <div class="corner"></div>
      <div id="topNums" class="number-row"></div>
      <div class="corner"></div>
    </div>

    <div class="middle-row">
      <div id="leftNums" class="number-col"></div>
      <div id="grid" class="grid"></div>
      <div id="rightNums" class="number-col"></div>
    </div>

    <div class="bottom-row">
      <div class="corner"></div>
      <div id="bottomNums" class="number-row"></div>
      <div class="corner"></div>
    </div>

  </div>
</div>

<script>
  "use strict";

  // -------------------------------------------------------------------
  // Config and constants
  // -------------------------------------------------------------------

  const MIN_SIZE   = 5;
  const MAX_SIZE   = 50;
  const STEP_SIZE  = 5;
  const MIN_ZOOM   = 0.4;
  const MAX_ZOOM   = 3.0;
  const ZOOM_IN_F  = 1.1;
  const ZOOM_OUT_F = 0.9;

  const MODE_LINE = "line";
  const MODE_RECT = "rect";
  const MODE_FREE = "free";

  const BUTTON_LEFT  = 0;
  const BUTTON_RIGHT = 2;

  const STATE_EMPTY  = "empty";
  const STATE_FILLED = "filled";
  const STATE_CROSS  = "cross";

  // -------------------------------------------------------------------
  // DOM references
  // -------------------------------------------------------------------

  const gridElement  = document.getElementById("grid");
  const colsInput    = document.getElementById("colsInput");
  const rowsInput    = document.getElementById("rowsInput");
  const buildBtn     = document.getElementById("buildGridBtn");

  const topNums      = document.getElementById("topNums");
  const bottomNums   = document.getElementById("bottomNums");
  const leftNums     = document.getElementById("leftNums");
  const rightNums    = document.getElementById("rightNums");

  const boardRoot    = document.getElementById("boardRoot");
  const boardWrapper = document.getElementById("boardWrapper");

  const themeRadios  = document.querySelectorAll('input[name="theme"]');
  const modeRadios   = document.querySelectorAll('input[name="mode"]');

  const tooltip      = document.createElement("div");
  tooltip.className  = "selection-tooltip";
  document.body.appendChild(tooltip);

  // -------------------------------------------------------------------
  // State
  // -------------------------------------------------------------------

  const state = {
    selectionMode: MODE_RECT,
    isMouseDown: false,
    dragStartRow: null,
    dragStartCol: null,
    dragButton: null,
    dragTargetState: null,
    cols: 25,
    rows: 25,
    originalStates: null,
    zoom: 1
  };

  // -------------------------------------------------------------------
  // Helper functions
  // -------------------------------------------------------------------

  function clampGridSize(value) {
    let n = parseInt(value, 10);
    if (isNaN(n)) n = 25;
    n = Math.max(MIN_SIZE, Math.min(MAX_SIZE, n));
    n = Math.round(n / STEP_SIZE) * STEP_SIZE;
    return n;
  }

  function getCellState(cell) {
    return cell.dataset.state || STATE_EMPTY;
  }

  function applyBoxShadowForState(cell, baseShadow, stateName) {
    const gridShadow = baseShadow || "";
    if (stateName === STATE_FILLED) {
      const inset = "inset 0 0 0 2px var(--grid-bg)";
      cell.style.boxShadow = gridShadow ? `${gridShadow}, ${inset}` : inset;
    } else {
      cell.style.boxShadow = gridShadow;
    }
  }

  function setCellState(cell, newState) {
    cell.dataset.state = newState;
    cell.classList.remove("filled", "cross");

    if (newState === STATE_FILLED) {
      cell.classList.add("filled");
    } else if (newState === STATE_CROSS) {
      cell.classList.add("cross");
    }

    applyBoxShadowForState(cell, cell.dataset.gridShadow, newState);
  }

  function nextStateLeft(current) {
    if (current === STATE_EMPTY)  return STATE_FILLED;
    if (current === STATE_FILLED) return STATE_CROSS;
    return STATE_EMPTY;
  }

  function nextStateRight(current) {
    if (current === STATE_EMPTY)  return STATE_CROSS;
    if (current === STATE_CROSS)  return STATE_FILLED;
    return STATE_EMPTY;
  }

  function indexFromRowCol(row, col) {
    return row * state.cols + col;
  }

  function snapshotGrid() {
    const cells = gridElement.children;
    const len   = cells.length;
    const snap  = new Array(len);

    for (let i = 0; i < len; i++) {
      snap[i] = cells[i].dataset.state || STATE_EMPTY;
    }
    state.originalStates = snap;
  }

  function restoreGridFromSnapshot() {
    const snap = state.originalStates;
    if (!snap) return;

    const cells = gridElement.children;
    if (cells.length !== snap.length) return;

    for (let i = 0; i < cells.length; i++) {
      setCellState(cells[i], snap[i]);
    }
  }

  function showTooltip(text, x, y) {
    tooltip.textContent   = text;
    tooltip.style.left    = (x + 12) + "px";
    tooltip.style.top     = (y + 12) + "px";
    tooltip.style.display = "block";
  }

  function hideTooltip() {
    tooltip.style.display = "none";
  }

  function applyZoom() {
    boardRoot.style.transform = `scale(${state.zoom})`;
  }

  function setTheme(mode) {
    document.body.setAttribute("data-theme", mode);
  }

  function getDragSize(row, col) {
    return {
      width:  Math.abs(col - state.dragStartCol) + 1,
      height: Math.abs(row - state.dragStartRow) + 1
    };
  }

  // -------------------------------------------------------------------
  // Number strips
  // -------------------------------------------------------------------

  function buildNumberRow(container, count) {
    container.innerHTML = "";
    container.style.gridTemplateColumns = `repeat(${count}, var(--cell-size))`;
    for (let i = 1; i <= count; i++) {
      const div = document.createElement("div");
      div.textContent = i;
      container.appendChild(div);
    }
  }

  function buildNumberCol(container, count) {
    container.innerHTML = "";
    container.style.gridTemplateRows = `repeat(${count}, var(--cell-size))`;
    for (let i = 1; i <= count; i++) {
      const div = document.createElement("div");
      div.textContent = i;
      container.appendChild(div);
    }
  }

  // -------------------------------------------------------------------
  // Grid building
  // -------------------------------------------------------------------

  function computeGridShadow(row, col, rows, cols) {
    const shadows = [];

    // Outer borders: thickness 3 (1px border + 2px shadow)
    if (row === 0) {
      shadows.push("0 -1px 0 0 #000", "0 -2px 0 0 #000");
    }
    if (row === rows - 1) {
      shadows.push("0 1px 0 0 #000", "0 2px 0 0 #000");
    }
    if (col === 0) {
      shadows.push("-1px 0 0 0 #000", "-2px 0 0 0 #000");
    }
    if (col === cols - 1) {
      shadows.push("1px 0 0 0 #000", "2px 0 0 0 #000");
    }

    // Internal 5x5 boundaries: thickness 2 (1px border + 1px shadow)
    if (row > 0 && row % 5 === 0) {
      shadows.push("0 -1px 0 0 #000");
    }
    if (col > 0 && col % 5 === 0) {
      shadows.push("-1px 0 0 0 #000");
    }

    return shadows.join(", ");
  }

  function buildGrid() {
    const cols = clampGridSize(colsInput.value);
    const rows = clampGridSize(rowsInput.value);

    colsInput.value = cols;
    rowsInput.value = rows;

    state.cols = cols;
    state.rows = rows;

    buildNumberRow(topNums, cols);
    buildNumberRow(bottomNums, cols);
    buildNumberCol(leftNums, rows);
    buildNumberCol(rightNums, rows);

    gridElement.innerHTML = "";
    gridElement.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.state = STATE_EMPTY;
        cell.dataset.row = String(r);
        cell.dataset.col = String(c);

        const shadow = computeGridShadow(r, c, rows, cols);
        cell.dataset.gridShadow = shadow;
        applyBoxShadowForState(cell, shadow, STATE_EMPTY);

        cell.addEventListener("mousedown", onCellMouseDown);
        cell.addEventListener("mouseenter", onCellMouseEnter);

        gridElement.appendChild(cell);
      }
    }
  }

  // -------------------------------------------------------------------
  // Drawing (line / rect)
  // -------------------------------------------------------------------

  function drawLineTo(row, col) {
    const dr = row - state.dragStartRow;
    const dc = col - state.dragStartCol;

    if (Math.abs(dr) >= Math.abs(dc)) {
      // Vertical line
      const r1 = Math.min(state.dragStartRow, row);
      const r2 = Math.max(state.dragStartRow, row);
      for (let r = r1; r <= r2; r++) {
        const idx = indexFromRowCol(r, state.dragStartCol);
        setCellState(gridElement.children[idx], state.dragTargetState);
      }
    } else {
      // Horizontal line
      const c1 = Math.min(state.dragStartCol, col);
      const c2 = Math.max(state.dragStartCol, col);
      for (let c = c1; c <= c2; c++) {
        const idx = indexFromRowCol(state.dragStartRow, c);
        setCellState(gridElement.children[idx], state.dragTargetState);
      }
    }
  }

  function drawRectTo(row, col) {
    const r1 = Math.min(state.dragStartRow, row);
    const r2 = Math.max(state.dragStartRow, row);
    const c1 = Math.min(state.dragStartCol, col);
    const c2 = Math.max(state.dragStartCol, col);

    for (let r = r1; r <= r2; r++) {
      for (let c = c1; c <= c2; c++) {
        const idx = indexFromRowCol(r, c);
        setCellState(gridElement.children[idx], state.dragTargetState);
      }
    }
  }

  // -------------------------------------------------------------------
  // Cell event handlers
  // -------------------------------------------------------------------

  function onCellMouseDown(event) {
    if (event.button !== BUTTON_LEFT && event.button !== BUTTON_RIGHT) return;

    event.preventDefault();
    hideTooltip();

    const cell = event.currentTarget;
    const row  = Number(cell.dataset.row);
    const col  = Number(cell.dataset.col);

    const current = getCellState(cell);
    const next = (event.button === BUTTON_LEFT)
      ? nextStateLeft(current)
      : nextStateRight(current);

    setCellState(cell, next);

    state.isMouseDown     = true;
    state.dragButton      = event.button;
    state.dragStartRow    = row;
    state.dragStartCol    = col;
    state.dragTargetState = next;

    if (state.selectionMode === MODE_FREE) {
      state.originalStates = null;
      return;
    }

    snapshotGrid();
    showTooltip("1x1", event.clientX, event.clientY);
  }

  function onCellMouseEnter(event) {
    if (!state.isMouseDown) return;

    const cell = event.currentTarget;
    const row  = Number(cell.dataset.row);
    const col  = Number(cell.dataset.col);

    if (state.selectionMode === MODE_FREE) {
      const current = getCellState(cell);
      const next = (state.dragButton === BUTTON_LEFT)
        ? nextStateLeft(current)
        : nextStateRight(current);
      setCellState(cell, next);
      return;
    }

    restoreGridFromSnapshot();

    if (state.selectionMode === MODE_LINE) {
      drawLineTo(row, col);
    } else if (state.selectionMode === MODE_RECT) {
      drawRectTo(row, col);
    }
  }

  // -------------------------------------------------------------------
  // Tooltip follow logic
  // -------------------------------------------------------------------

  gridElement.addEventListener("mousemove", (event) => {
    if (!state.isMouseDown || state.selectionMode === MODE_FREE) {
      hideTooltip();
      return;
    }

    const cell = event.target.closest(".cell");
    if (!cell) return;

    const row = Number(cell.dataset.row);
    const col = Number(cell.dataset.col);

    let { width, height } = getDragSize(row, col);

    if (state.selectionMode === MODE_LINE) {
      const dr = row - state.dragStartRow;
      const dc = col - state.dragStartCol;
      if (Math.abs(dr) >= Math.abs(dc)) {
        width  = 1;
        height = Math.abs(dr) + 1;
      } else {
        width  = Math.abs(dc) + 1;
        height = 1;
      }
    }

    showTooltip(`${width}x${height}`, event.clientX, event.clientY);
  });

  // -------------------------------------------------------------------
  // Global events
  // -------------------------------------------------------------------

  document.addEventListener("mouseup", () => {
    state.isMouseDown     = false;
    state.dragStartRow    = null;
    state.dragStartCol    = null;
    state.dragButton      = null;
    state.dragTargetState = null;
    state.originalStates  = null;
    hideTooltip();
  });

  gridElement.addEventListener("contextmenu", (event) => {
    event.preventDefault();
  });

  // Zoom: Ctrl or Cmd + wheel
  boardWrapper.addEventListener("wheel", (event) => {
    const isZoomGesture = event.ctrlKey || event.metaKey;
    if (!isZoomGesture) return;

    event.preventDefault();
    const delta  = event.deltaY || 0;
    const factor = delta < 0 ? ZOOM_IN_F : ZOOM_OUT_F;

    state.zoom *= factor;
    state.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, state.zoom));
    applyZoom();
  }, { passive: false });

  // Mode switching
  modeRadios.forEach(radio => {
    radio.addEventListener("change", () => {
      if (!radio.checked) return;
      state.selectionMode = radio.value;
      if (state.selectionMode === MODE_FREE) hideTooltip();
    });
  });

  // Theme switching
  themeRadios.forEach(radio => {
    radio.addEventListener("change", () => {
      if (!radio.checked) return;
      setTheme(radio.value);
    });
  });

  // Build/reset
  buildBtn.addEventListener("click", () => {
    hideTooltip();
    buildGrid();
  });

  // -------------------------------------------------------------------
  // Initialisation
  // -------------------------------------------------------------------

  setTheme("dark");
  buildGrid();
  applyZoom();
</script>

</body>
</html>
