<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Nonogram Scratchpad</title>

<style>
  :root {
    --cell-size: 22px;
    --grid-font: system-ui, -apple-system, "Segoe UI", sans-serif;
  }

  body {
    font-family: var(--grid-font);
    max-width: 1000px;
    margin: 20px auto;
    padding: 0 16px 40px;
    background: rgb(29,31,33); /* dark mode background */
    color: #eee;
    transition: background 0.15s ease, color 0.15s ease;
  }

  body[data-theme="light"] {
    background: #f4f4f8;
    color: #222;
  }

  h1 {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
  }

  /* Controls */

  .top-bar {
    display: flex;
    justify-content: space-between;
    gap: 16px;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 8px;
  }

  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
  }

  .controls label {
    font-size: 0.95rem;
  }

  .controls input[type="number"] {
    width: 70px;
    padding: 3px 6px;
  }

  .theme-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
  }

  .theme-toggle label {
    cursor: pointer;
  }

  button {
    padding: 6px 12px;
    border-radius: 6px;
    border: 1px solid #666;
    background: #333;
    color: #f5f5f5;
    cursor: pointer;
    font-size: 0.95rem;
    transition: background 0.1s ease, filter 0.1s ease, border-color 0.1s ease;
  }

  button:hover {
    filter: brightness(1.1);
  }

  body[data-theme="light"] button {
    background: #f4f4f4;
    color: #222;
    border-color: #bbb;
  }

  .mode-select {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-bottom: 16px;
    font-size: 0.9rem;
  }

  .mode-select label {
    cursor: pointer;
  }

  /* Board */

  .board-wrapper {
    overflow: visible;
    max-height: none;
  }

  .board {
    display: flex;
    flex-direction: column;
    gap: 4px;
    user-select: none;
    transform-origin: top left;
  }

  .top-row,
  .bottom-row {
    display: flex;
    align-items: flex-start;
    gap: 4px;
  }

  .middle-row {
    display: flex;
    align-items: flex-start;
    gap: 4px;
  }

  .corner {
    width: var(--cell-size);
    height: var(--cell-size);
  }

  .number-row {
    display: grid;
  }

  .number-col {
    display: grid;
  }

  .number-row > div,
  .number-col > div {
    font-size: 12px;
    text-align: center;
    line-height: var(--cell-size);
    width: var(--cell-size);
    height: var(--cell-size);
    color: #ccc;
  }

  body[data-theme="light"] .number-row > div,
  body[data-theme="light"] .number-col > div {
    color: #444;
  }

  .grid {
    display: grid;
  }

  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    box-sizing: border-box;
    border: 1px solid #000;                 /* grid lines */
    background: rgb(218,210,192);           /* grid background colour */
    font-size: 16px;
    line-height: var(--cell-size);
    text-align: center;
    cursor: pointer;
    position: relative;
  }

  .cell.filled {
    background: #000;
    color: #000;
    /* Thicker inner outline, matching grid background colour */
    box-shadow: inset 0 0 0 2px rgb(218,210,192);
  }

  /* Bold centred red cross */

  .cell.cross {
    background: rgb(218,210,192);
  }

  .cell.cross::after {
    content: "Ã—";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 20px;
    font-weight: bold;
    line-height: 1;
    color: #c00;
    pointer-events: none;
  }

  /* Tooltip */

  .selection-tooltip {
    position: fixed;
    padding: 2px 6px;
    font-size: 11px;
    background: rgba(0, 0, 0, 0.8);
    color: #fff;
    border-radius: 4px;
    pointer-events: none;
    z-index: 1000;
    display: none;
  }
</style>
</head>
<body data-theme="dark">

<h1>Nonogram Scratchpad</h1>

<div class="top-bar">
  <div class="controls">
    <label>
      Columns (width):
      <input type="number" id="colsInput" min="5" max="50" step="5" value="25">
    </label>
    <label>
      Rows (height):
      <input type="number" id="rowsInput" min="5" max="50" step="5" value="25">
    </label>
    <button id="buildGridBtn">Create / reset grid</button>
  </div>

  <div class="theme-toggle">
    <span>Theme:</span>
    <label><input type="radio" name="theme" value="dark" checked> Dark</label>
    <label><input type="radio" name="theme" value="light"> Light</label>
  </div>
</div>

<div class="mode-select">
  <span>Selection mode:</span>
  <label><input type="radio" name="mode" value="line" checked> Straight line</label>
  <label><input type="radio" name="mode" value="rect"> Rectangle</label>
  <label><input type="radio" name="mode" value="free"> Freestyle</label>
</div>

<div class="board-wrapper" id="boardWrapper">
  <div class="board" id="boardRoot">

    <div class="top-row">
      <div class="corner"></div>
      <div id="topNums" class="number-row"></div>
      <div class="corner"></div>
    </div>

    <div class="middle-row">
      <div id="leftNums" class="number-col"></div>
      <div id="grid" class="grid"></div>
      <div id="rightNums" class="number-col"></div>
    </div>

    <div class="bottom-row">
      <div class="corner"></div>
      <div id="bottomNums" class="number-row"></div>
      <div class="corner"></div>
    </div>

  </div>
</div>

<script>
  /* CONFIG */

  const MIN_SIZE = 5;
  const MAX_SIZE = 50;
  const STEP_SIZE = 5;
  const MIN_ZOOM = 0.4;
  const MAX_ZOOM = 3.0;
  const ZOOM_IN = 1.1;
  const ZOOM_OUT = 0.9;

  /* DOM REFS */

  const gridElement = document.getElementById("grid");
  const colsInput   = document.getElementById("colsInput");
  const rowsInput   = document.getElementById("rowsInput");
  const buildBtn    = document.getElementById("buildGridBtn");

  const topNums    = document.getElementById("topNums");
  const bottomNums = document.getElementById("bottomNums");
  const leftNums   = document.getElementById("leftNums");
  const rightNums  = document.getElementById("rightNums");

  const boardRoot    = document.getElementById("boardRoot");
  const boardWrapper = document.getElementById("boardWrapper");

  const themeRadios = document.querySelectorAll('input[name="theme"]');

  const tooltip = document.createElement("div");
  tooltip.className = "selection-tooltip";
  document.body.appendChild(tooltip);

  /* STATE */

  const state = {
    selectionMode: "line",
    isMouseDown: false,
    dragStartRow: null,
    dragStartCol: null,
    dragButton: null,
    dragTargetState: null,
    cols: 25,
    rows: 25,
    originalStates: null,
    zoom: 1
  };

  /* HELPERS */

  function clampGridSize(n) {
    n = parseInt(n, 10);
    if (isNaN(n)) n = 25;
    n = Math.max(MIN_SIZE, Math.min(MAX_SIZE, n));
    n = Math.round(n / STEP_SIZE) * STEP_SIZE;
    return n;
  }

  function getState(cell) {
    return cell.dataset.state || "empty";
  }

  function setState(cell, st) {
    cell.dataset.state = st;
    cell.classList.remove("filled", "cross");

    if (st === "filled") {
      cell.classList.add("filled");
    }
    if (st === "cross") {
      cell.classList.add("cross");
    }
  }

  function nextLeft(st) {
    if (st === "empty") return "filled";
    if (st === "filled") return "cross";
    return "empty";
  }

  function nextRight(st) {
    if (st === "empty") return "cross";
    if (st === "cross") return "filled";
    return "empty";
  }

  function idx(r, c) {
    return r * state.cols + c;
  }

  function snapshot() {
    state.originalStates = Array.from(gridElement.children, c => c.dataset.state);
  }

  function restore() {
    if (!state.originalStates) return;
    gridElement.childNodes.forEach((cell, i) => {
      setState(cell, state.originalStates[i]);
    });
  }

  function showTooltip(text, x, y) {
    tooltip.textContent = text;
    tooltip.style.left = (x + 12) + "px";
    tooltip.style.top  = (y + 12) + "px";
    tooltip.style.display = "block";
  }

  function hideTooltip() {
    tooltip.style.display = "none";
  }

  function applyZoom() {
    boardRoot.style.transform = `scale(${state.zoom})`;
  }

  function setTheme(mode) {
    document.body.setAttribute("data-theme", mode);
  }

  /* GRID BUILDING */

  function buildNumbersRow(container, count) {
    container.innerHTML = "";
    container.style.gridTemplateColumns = `repeat(${count}, var(--cell-size))`;
    for (let i = 1; i <= count; i++) {
      const n = document.createElement("div");
      n.textContent = i;
      container.appendChild(n);
    }
  }

  function buildNumbersCol(container, count) {
    container.innerHTML = "";
    container.style.gridTemplateRows = `repeat(${count}, var(--cell-size))`;
    for (let i = 1; i <= count; i++) {
      const n = document.createElement("div");
      n.textContent = i;
      container.appendChild(n);
    }
  }

  function buildGrid() {
    const cols = clampGridSize(colsInput.value);
    const rows = clampGridSize(rowsInput.value);

    colsInput.value = cols;
    rowsInput.value = rows;

    state.cols = cols;
    state.rows = rows;

    buildNumbersRow(topNums, cols);
    buildNumbersRow(bottomNums, cols);
    buildNumbersCol(leftNums, rows);
    buildNumbersCol(rightNums, rows);

    gridElement.innerHTML = "";
    gridElement.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.state = "empty";
        cell.dataset.row = r;
        cell.dataset.col = c;

        const t  = r === 0 ? 3 : r % 5 === 0 ? 2 : 1;
        const l  = c === 0 ? 3 : c % 5 === 0 ? 2 : 1;
        const b  = r === rows - 1 ? 3 : (r + 1) % 5 === 0 ? 2 : 1;
        const rt = c === cols - 1 ? 3 : (c + 1) % 5 === 0 ? 2 : 1;

        cell.style.borderTopWidth    = t  + "px";
        cell.style.borderLeftWidth   = l  + "px";
        cell.style.borderBottomWidth = b  + "px";
        cell.style.borderRightWidth  = rt + "px";

        cell.addEventListener("mousedown", cellMouseDown);
        cell.addEventListener("mouseenter", cellMouseEnter);

        gridElement.appendChild(cell);
      }
    }
  }

  /* DRAWING */

  function drawLineTo(row, col) {
    const dr = row - state.dragStartRow;
    const dc = col - state.dragStartCol;

    if (Math.abs(dr) >= Math.abs(dc)) {
      const r1 = Math.min(state.dragStartRow, row);
      const r2 = Math.max(state.dragStartRow, row);
      for (let r = r1; r <= r2; r++) {
        setState(gridElement.children[idx(r, state.dragStartCol)], state.dragTargetState);
      }
    } else {
      const c1 = Math.min(state.dragStartCol, col);
      const c2 = Math.max(state.dragStartCol, col);
      for (let c = c1; c <= c2; c++) {
        setState(gridElement.children[idx(state.dragStartRow, c)], state.dragTargetState);
      }
    }
  }

  function drawRectTo(row, col) {
    const r1 = Math.min(state.dragStartRow, row);
    const r2 = Math.max(state.dragStartRow, row);
    const c1 = Math.min(state.dragStartCol, col);
    const c2 = Math.max(state.dragStartCol, col);

    for (let r = r1; r <= r2; r++) {
      for (let c = c1; c <= c2; c++) {
        setState(gridElement.children[idx(r, c)], state.dragTargetState);
      }
    }
  }

  /* CELL EVENTS */

  function cellMouseDown(event) {
    if (event.button !== 0 && event.button !== 2) return;

    event.preventDefault();
    hideTooltip();

    const cell = event.currentTarget;
    const row  = Number(cell.dataset.row);
    const col  = Number(cell.dataset.col);

    const current = getState(cell);
    const next = event.button === 0 ? nextLeft(current) : nextRight(current);

    setState(cell, next);

    state.isMouseDown = true;
    state.dragButton = event.button;
    state.dragStartRow = row;
    state.dragStartCol = col;
    state.dragTargetState = next;

    if (state.selectionMode !== "free") {
      snapshot();
      showTooltip("1x1", event.clientX, event.clientY);
    } else {
      state.originalStates = null;
    }
  }

  function cellMouseEnter(event) {
    if (!state.isMouseDown) return;

    const cell = event.currentTarget;
    const row  = Number(cell.dataset.row);
    const col  = Number(cell.dataset.col);

    if (state.selectionMode === "free") {
      const cur = getState(cell);
      const next = state.dragButton === 0 ? nextLeft(cur) : nextRight(cur);
      setState(cell, next);
      return;
    }

    restore();
    if (state.selectionMode === "line") {
      drawLineTo(row, col);
    } else if (state.selectionMode === "rect") {
      drawRectTo(row, col);
    }
  }

  /* TOOLTIP FOLLOW */

  gridElement.addEventListener("mousemove", (event) => {
    if (!state.isMouseDown || state.selectionMode === "free") {
      hideTooltip();
      return;
    }

    const cell = event.target.closest(".cell");
    if (!cell) return;

    const row = Number(cell.dataset.row);
    const col = Number(cell.dataset.col);

    let width  = Math.abs(col - state.dragStartCol) + 1;
    let height = Math.abs(row - state.dragStartRow) + 1;

    if (state.selectionMode === "line") {
      const dr = row - state.dragStartRow;
      const dc = col - state.dragStartCol;
      if (Math.abs(dr) >= Math.abs(dc)) {
        width = 1;
        height = Math.abs(dr) + 1;
      } else {
        width = Math.abs(dc) + 1;
        height = 1;
      }
    }

    showTooltip(`${width}x${height}`, event.clientX, event.clientY);
  });

  /* GLOBAL EVENTS */

  document.addEventListener("mouseup", () => {
    state.isMouseDown = false;
    state.dragStartRow = null;
    state.dragStartCol = null;
    state.dragButton = null;
    state.dragTargetState = null;
    state.originalStates = null;
    hideTooltip();
  });

  gridElement.addEventListener("contextmenu", e => e.preventDefault());

  // Zoom: Ctrl (Win/Linux) or Cmd (macOS) + wheel
  boardWrapper.addEventListener("wheel", (event) => {
    const isZoomGesture = event.ctrlKey || event.metaKey;
    if (!isZoomGesture) return;

    event.preventDefault();
    const delta = event.deltaY;
    state.zoom *= delta < 0 ? ZOOM_IN : ZOOM_OUT;
    state.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, state.zoom));
    applyZoom();
  }, { passive: false });

  // Mode switching
  document.querySelectorAll('input[name="mode"]').forEach(radio => {
    radio.addEventListener("change", () => {
      if (radio.checked) {
        state.selectionMode = radio.value;
        if (state.selectionMode === "free") hideTooltip();
      }
    });
  });

  // Theme switching
  themeRadios.forEach(radio => {
    radio.addEventListener("change", () => {
      if (radio.checked) {
        setTheme(radio.value);
      }
    });
  });

  // Build/reset
  buildBtn.addEventListener("click", () => {
    hideTooltip();
    buildGrid();
  });

  /* INIT */

  setTheme("dark"); // default
  buildGrid();
  applyZoom();
</script>

</body>
</html>
