<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Nonogram Scratchpad</title>

<style>
  :root {
    --cell-size: 22px;
    --grid-font: system-ui, -apple-system, "Segoe UI", sans-serif;
    --grid-bg: rgb(218,210,192);
    --dark-bg: rgb(29,31,33);
  }

  body {
    font-family: var(--grid-font);
    max-width: 1000px;
    margin: 20px auto;
    padding: 0 16px 40px;
    background: var(--dark-bg);
    color: #eee;
    transition: background 0.15s ease, color 0.15s ease;
  }

  body[data-theme="light"] {
    background: #f4f4f8;
    color: #222;
  }

  h1 {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
  }

  /* Controls */

  .top-bar {
    display: flex;
    justify-content: space-between;
    gap: 16px;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 8px;
  }

  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
  }

  .controls label {
    font-size: 0.95rem;
  }

  .controls input[type="number"] {
    width: 70px;
    padding: 3px 6px;
  }

  .theme-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
  }

  .theme-toggle label {
    cursor: pointer;
  }

  .history-controls {
    display: flex;
    gap: 8px;
    align-items: center;
    font-size: 0.85rem;
  }

  button {
    padding: 6px 12px;
    border-radius: 6px;
    border: 1px solid #666;
    background: #333;
    color: #f5f5f5;
    cursor: pointer;
    font-size: 0.95rem;
    transition: background 0.1s ease, filter 0.1s ease, border-color 0.1s ease;
  }

  button:hover {
    filter: brightness(1.1);
  }

  button:disabled {
    opacity: 0.4;
    cursor: default;
    filter: none;
  }

  body[data-theme="light"] button {
    background: #f4f4f4;
    color: #222;
    border-color: #bbb;
  }

  .mode-select {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-bottom: 16px;
    font-size: 0.9rem;
  }

  .mode-select label {
    cursor: pointer;
  }

  /* Board */

  .board-wrapper {
    overflow: visible;
    max-height: none;
  }

  .board {
    display: flex;
    flex-direction: column;
    gap: 4px;
    user-select: none;
  }

  .top-row,
  .bottom-row {
    display: flex;
    align-items: flex-start;
    gap: 4px;
  }

  .middle-row {
    display: flex;
    align-items: flex-start;
    gap: 4px;
  }

  .corner {
    width: var(--cell-size);
    height: var(--cell-size);
  }

  .number-row {
    display: grid;
  }

  .number-col {
    display: grid;
  }

  .number-row > div,
  .number-col > div {
    font-size: 12px;
    text-align: center;
    line-height: var(--cell-size);
    width: var(--cell-size);
    height: var(--cell-size);
    color: #ccc;
  }

  body[data-theme="light"] .number-row > div,
  body[data-theme="light"] .number-col > div {
    color: #444;
  }

  .grid {
    display: grid;
  }

  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    box-sizing: border-box;
    border: 1px solid #000;
    background: var(--grid-bg);
    cursor: pointer;
    position: relative;
    box-shadow: none;
  }

  .cell.filled {
    background: #000;
  }

  .cell.cross {
    background: var(--grid-bg);
  }

  .cell.cross::after {
    content: "×";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 20px;
    font-weight: bold;
    color: #c00;
    pointer-events: none;
  }

  /* Tooltip */

  .selection-tooltip {
    position: fixed;
    padding: 2px 6px;
    font-size: 11px;
    background: rgba(0, 0, 0, 0.8);
    color: #fff;
    border-radius: 4px;
    pointer-events: none;
    z-index: 1000;
    display: none;
  }

  /* Footer */

  footer {
    margin-top: 30px;
    padding-top: 12px;
    border-top: 1px solid #444;
    font-size: 0.9rem;
    text-align: center;
    color: #bbb;
  }

  body[data-theme="light"] footer {
    border-top-color: #ccc;
    color: #555;
  }

  footer a {
    color: #7abaff;
    text-decoration: none;
  }

  footer a:hover {
    text-decoration: underline;
  }
</style>
</head>
<body data-theme="dark">

<h1>Nonogram Scratchpad</h1>

<div class="top-bar">
  <div class="controls">
    <label>
      Columns (width):
      <input type="number" id="colsInput" min="5" max="50" step="5" value="25">
    </label>
    <label>
      Rows (height):
      <input type="number" id="rowsInput" min="5" max="50" step="5" value="25">
    </label>
    <button id="buildGridBtn">Create / reset grid</button>
  </div>

  <div class="history-controls">
    <button id="undoBtn" disabled>Undo</button>
    <button id="redoBtn" disabled>Redo</button>
    <span>(Ctrl/Cmd+Z, Ctrl+Y)</span>
  </div>

  <div class="theme-toggle">
    <span>Theme:</span>
    <label><input type="radio" name="theme" value="dark" checked> Dark</label>
    <label><input type="radio" name="theme" value="light"> Light</label>
  </div>
</div>

<div class="mode-select">
  <span>Selection mode:</span>
  <label><input type="radio" name="mode" value="line"> Straight line</label>
  <label><input type="radio" name="mode" value="rect" checked> Rectangle</label>
  <label><input type="radio" name="mode" value="free"> Freestyle</label>
</div>

<div class="board-wrapper" id="boardWrapper">
  <div class="board" id="boardRoot">

    <div class="top-row">
      <div class="corner"></div>
      <div id="topNums" class="number-row"></div>
      <div class="corner"></div>
    </div>

    <div class="middle-row">
      <div id="leftNums" class="number-col"></div>
      <div id="grid" class="grid"></div>
      <div id="rightNums" class="number-col"></div>
    </div>

    <div class="bottom-row">
      <div class="corner"></div>
      <div id="bottomNums" class="number-row"></div>
      <div class="corner"></div>
    </div>

  </div>
</div>

<footer>
  Source available on GitHub:<br>
  <a href="https://github.com/martbrooks/nonohelper" target="_blank">
    github.com/martbrooks/nonohelper
  </a>
</footer>

<script>
"use strict";

/* =====================================================================
   CONSTANTS & CONFIG
   ===================================================================== */

const BASE_CELL_SIZE = 22;   // px, matches initial --cell-size
const MIN_SIZE   = 5;
const MAX_SIZE   = 50;
const STEP_SIZE  = 5;
const MIN_ZOOM   = 0.4;
const MAX_ZOOM   = 3.0;
const ZOOM_IN_F  = 1.1;
const ZOOM_OUT_F = 0.9;

const MODE_LINE = "line";
const MODE_RECT = "rect";
const MODE_FREE = "free";

const BUTTON_LEFT  = 0;
const BUTTON_RIGHT = 2;

const STATE_EMPTY  = "empty";
const STATE_FILLED = "filled";
const STATE_CROSS  = "cross";

const MAX_HISTORY = 50;

/* =====================================================================
   DOM REFERENCES
   ===================================================================== */

const gridElement  = document.getElementById("grid");
const colsInput    = document.getElementById("colsInput");
const rowsInput    = document.getElementById("rowsInput");
const buildBtn     = document.getElementById("buildGridBtn");

const topNums      = document.getElementById("topNums");
const bottomNums   = document.getElementById("bottomNums");
const leftNums     = document.getElementById("leftNums");
const rightNums    = document.getElementById("rightNums");

const boardRoot    = document.getElementById("boardRoot");
const boardWrapper = document.getElementById("boardWrapper");

const themeRadios  = document.querySelectorAll('input[name="theme"]');
const modeRadios   = document.querySelectorAll('input[name="mode"]');

const undoBtn      = document.getElementById("undoBtn");
const redoBtn      = document.getElementById("redoBtn");

const tooltip      = document.createElement("div");
tooltip.className  = "selection-tooltip";
document.body.appendChild(tooltip);

/* =====================================================================
   STATE
   ===================================================================== */

const state = {
  selectionMode: MODE_RECT,
  isMouseDown: false,
  dragStartRow: null,
  dragStartCol: null,
  dragButton: null,
  dragTargetState: null,
  cols: 25,
  rows: 25,
  previewStates: null,   // for drag previews
  zoom: 1,
  history: [],           // undo/redo snapshots
  historyIndex: -1,
  changedThisDrag: false
};

/* =====================================================================
   GENERIC GRID STATE HELPERS
   ===================================================================== */

function readGridStates() {
  const cells = gridElement.children;
  const states = new Array(cells.length);
  for (let i = 0; i < cells.length; i++) {
    states[i] = cells[i].dataset.state || STATE_EMPTY;
  }
  return states;
}

function writeGridStates(states) {
  if (!states) return;
  const cells = gridElement.children;
  if (cells.length !== states.length) return;

  for (let i = 0; i < cells.length; i++) {
    const cell = cells[i];
    const s    = states[i];

    cell.dataset.state = s;
    cell.classList.remove("filled", "cross");
    if (s === STATE_FILLED) cell.classList.add("filled");
    if (s === STATE_CROSS)  cell.classList.add("cross");

    applyBoxShadowForState(cell, cell.dataset.gridShadow, s);
  }
}

/* =====================================================================
   BASIC UTILS
   ===================================================================== */

function clampGridSize(value) {
  let n = parseInt(value, 10);
  if (isNaN(n)) n = 25;
  n = Math.max(MIN_SIZE, Math.min(MAX_SIZE, n));
  return Math.round(n / STEP_SIZE) * STEP_SIZE;
}

function getCellState(cell) {
  return cell.dataset.state || STATE_EMPTY;
}

function applyBoxShadowForState(cell, baseShadow, newState) {
  const gridShadow = baseShadow || "";
  if (newState === STATE_FILLED) {
    const inset = "inset 0 0 0 2px var(--grid-bg)";
    cell.style.boxShadow = gridShadow ? `${gridShadow}, ${inset}` : inset;
  } else {
    cell.style.boxShadow = gridShadow;
  }
}

function setCellState(cell, newState) {
  const prev = cell.dataset.state || STATE_EMPTY;
  if (prev === newState) return;

  cell.dataset.state = newState;
  cell.classList.remove("filled", "cross");

  if (newState === STATE_FILLED) cell.classList.add("filled");
  if (newState === STATE_CROSS)  cell.classList.add("cross");

  applyBoxShadowForState(cell, cell.dataset.gridShadow, newState);
  state.changedThisDrag = true;
}

function nextStateLeft(current) {
  if (current === STATE_EMPTY)  return STATE_FILLED;
  if (current === STATE_FILLED) return STATE_CROSS;
  return STATE_EMPTY;
}

function nextStateRight(current) {
  if (current === STATE_EMPTY)  return STATE_CROSS;
  if (current === STATE_CROSS)  return STATE_FILLED;
  return STATE_EMPTY;
}

function indexFromRowCol(row, col) {
  return row * state.cols + col;
}

function showTooltip(text, x, y) {
  tooltip.textContent   = text;
  tooltip.style.left    = (x + 12) + "px";
  tooltip.style.top     = (y + 12) + "px";
  tooltip.style.display = "block";
}

function hideTooltip() {
  tooltip.style.display = "none";
}

function applyZoom() {
  const newSize = BASE_CELL_SIZE * state.zoom;
  document.documentElement.style.setProperty("--cell-size", `${newSize}px`);
}

function setTheme(mode) {
  document.body.setAttribute("data-theme", mode);
}

function getDragSize(row, col) {
  return {
    width:  Math.abs(col - state.dragStartCol) + 1,
    height: Math.abs(row - state.dragStartRow) + 1
  };
}

/* =====================================================================
   PREVIEW SNAPSHOT (FOR DRAG)
   ===================================================================== */

function snapshotPreview() {
  state.previewStates = readGridStates();
}

function restorePreview() {
  if (!state.previewStates) return;
  writeGridStates(state.previewStates);
}

/* =====================================================================
   UNDO / REDO HISTORY
   ===================================================================== */

function pushHistoryState() {
  const snapshot = readGridStates();

  if (state.historyIndex < state.history.length - 1) {
    state.history = state.history.slice(0, state.historyIndex + 1);
  }

  state.history.push(snapshot);

  if (state.history.length > MAX_HISTORY) {
    state.history.shift();
  }

  state.historyIndex = state.history.length - 1;
  updateHistoryButtons();
}

function applyHistorySnapshot(index) {
  if (index < 0 || index >= state.history.length) return;
  writeGridStates(state.history[index]);
  state.historyIndex = index;
  updateHistoryButtons();
}

function updateHistoryButtons() {
  undoBtn.disabled = state.historyIndex <= 0;
  redoBtn.disabled = state.historyIndex >= state.history.length - 1;
}

function undo() {
  if (state.historyIndex <= 0) return;
  applyHistorySnapshot(state.historyIndex - 1);
}

function redo() {
  if (state.historyIndex >= state.history.length - 1) return;
  applyHistorySnapshot(state.historyIndex + 1);
}

/* =====================================================================
   NUMBER STRIPS
   ===================================================================== */

function buildNumberRow(container, count) {
  container.innerHTML = "";
  container.style.gridTemplateColumns = `repeat(${count}, var(--cell-size))`;
  for (let i = 1; i <= count; i++) {
    const div = document.createElement("div");
    div.textContent = i;
    container.appendChild(div);
  }
}

function buildNumberCol(container, count) {
  container.innerHTML = "";
  container.style.gridTemplateRows = `repeat(${count}, var(--cell-size))`;
  for (let i = 1; i <= count; i++) {
    const div = document.createElement("div");
    div.textContent = i;
    container.appendChild(div);
  }
}

/* =====================================================================
   GRID BUILDING
   ===================================================================== */

function computeGridShadow(row, col, rows, cols) {
  const shadows = [];

  // Outer borders: thickness 3 (1px border + 2px shadows)
  if (row === 0)      shadows.push("0 -1px 0 0 #000", "0 -2px 0 0 #000");
  if (row === rows-1) shadows.push("0 1px 0 0 #000",  "0 2px 0 0 #000");
  if (col === 0)      shadows.push("-1px 0 0 0 #000", "-2px 0 0 0 #000");
  if (col === cols-1) shadows.push("1px 0 0 0 #000",  "2px 0 0 0 #000");

  // Internal 5×5 boundaries (extra 1px shadow)
  if (row > 0 && row % 5 === 0) shadows.push("0 -1px 0 0 #000");
  if (col > 0 && col % 5 === 0) shadows.push("-1px 0 0 0 #000");

  return shadows.join(", ");
}

function buildGrid() {
  const cols = clampGridSize(colsInput.value);
  const rows = clampGridSize(rowsInput.value);

  colsInput.value = cols;
  rowsInput.value = rows;

  state.cols = cols;
  state.rows = rows;

  buildNumberRow(topNums, cols);
  buildNumberRow(bottomNums, cols);
  buildNumberCol(leftNums, rows);
  buildNumberCol(rightNums, rows);

  gridElement.innerHTML = "";
  gridElement.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.state = STATE_EMPTY;
      cell.dataset.row = String(r);
      cell.dataset.col = String(c);

      const shadow = computeGridShadow(r, c, rows, cols);
      cell.dataset.gridShadow = shadow;
      applyBoxShadowForState(cell, shadow, STATE_EMPTY);

      cell.addEventListener("mousedown", onCellMouseDown);
      cell.addEventListener("mouseenter", onCellMouseEnter);

      gridElement.appendChild(cell);
    }
  }

  state.history = [];
  state.historyIndex = -1;
  pushHistoryState();
}

/* =====================================================================
   DRAWING (LINE / RECT)
   ===================================================================== */

function drawLineTo(row, col) {
  const dr = row - state.dragStartRow;
  const dc = col - state.dragStartCol;

  if (Math.abs(dr) >= Math.abs(dc)) {
    const r1 = Math.min(state.dragStartRow, row);
    const r2 = Math.max(state.dragStartRow, row);
    for (let r = r1; r <= r2; r++) {
      const idx = indexFromRowCol(r, state.dragStartCol);
      setCellState(gridElement.children[idx], state.dragTargetState);
    }
  } else {
    const c1 = Math.min(state.dragStartCol, col);
    const c2 = Math.max(state.dragStartCol, col);
    for (let c = c1; c <= c2; c++) {
      const idx = indexFromRowCol(state.dragStartRow, c);
      setCellState(gridElement.children[idx], state.dragTargetState);
    }
  }
}

function drawRectTo(row, col) {
  const r1 = Math.min(state.dragStartRow, row);
  const r2 = Math.max(state.dragStartRow, row);
  const c1 = Math.min(state.dragStartCol, col);
  const c2 = Math.max(state.dragStartCol, col);

  for (let r = r1; r <= r2; r++) {
    for (let c = c1; c <= c2; c++) {
      const idx = indexFromRowCol(r, c);
      setCellState(gridElement.children[idx], state.dragTargetState);
    }
  }
}

/* =====================================================================
   CELL EVENT HANDLERS
   ===================================================================== */

function onCellMouseDown(event) {
  if (event.button !== BUTTON_LEFT && event.button !== BUTTON_RIGHT) return;

  event.preventDefault();
  hideTooltip();

  const cell = event.currentTarget;
  const row  = Number(cell.dataset.row);
  const col  = Number(cell.dataset.col);

  const current = getCellState(cell);
  const next    = (event.button === BUTTON_LEFT)
                    ? nextStateLeft(current)
                    : nextStateRight(current);

  state.changedThisDrag = false;

  setCellState(cell, next);

  state.isMouseDown     = true;
  state.dragButton      = event.button;
  state.dragStartRow    = row;
  state.dragStartCol    = col;
  state.dragTargetState = next;

  if (state.selectionMode === MODE_FREE) {
    state.previewStates = null;
    return;
  }

  snapshotPreview();
  showTooltip("1x1", event.clientX, event.clientY);
}

function onCellMouseEnter(event) {
  if (!state.isMouseDown) return;

  const cell = event.currentTarget;
  const row  = Number(cell.dataset.row);
  const col  = Number(cell.dataset.col);

  if (state.selectionMode === MODE_FREE) {
    const current = getCellState(cell);
    const next    = (state.dragButton === BUTTON_LEFT)
                      ? nextStateLeft(current)
                      : nextStateRight(current);
    setCellState(cell, next);
    return;
  }

  restorePreview();

  if (state.selectionMode === MODE_LINE) {
    drawLineTo(row, col);
  } else {
    drawRectTo(row, col);
  }
}

/* =====================================================================
   TOOLTIP FOLLOWING
   ===================================================================== */

gridElement.addEventListener("mousemove", (event) => {
  if (!state.isMouseDown || state.selectionMode === MODE_FREE) {
    hideTooltip();
    return;
  }

  const cell = event.target.closest(".cell");
  if (!cell) return;

  const row = Number(cell.dataset.row);
  const col = Number(cell.dataset.col);

  let { width, height } = getDragSize(row, col);

  if (state.selectionMode === MODE_LINE) {
    const dr = row - state.dragStartRow;
    const dc = col - state.dragStartCol;
    if (Math.abs(dr) >= Math.abs(dc)) {
      width  = 1;
      height = Math.abs(dr) + 1;
    } else {
      width  = Math.abs(dc) + 1;
      height = 1;
    }
  }

  showTooltip(`${width}x${height}`, event.clientX, event.clientY);
});

/* =====================================================================
   GLOBAL EVENTS
   ===================================================================== */

document.addEventListener("mouseup", () => {
  if (state.isMouseDown && state.changedThisDrag) {
    pushHistoryState();
  }

  state.isMouseDown     = false;
  state.dragStartRow    = null;
  state.dragStartCol    = null;
  state.dragButton      = null;
  state.dragTargetState = null;
  state.previewStates   = null;
  state.changedThisDrag = false;
  hideTooltip();
});

gridElement.addEventListener("contextmenu", (event) => {
  event.preventDefault();
});

/* Zoom: Ctrl/Cmd + wheel */
boardWrapper.addEventListener("wheel", (event) => {
  const isZoomGesture = event.ctrlKey || event.metaKey;
  if (!isZoomGesture) return;

  event.preventDefault();
  const delta  = event.deltaY || 0;
  const factor = delta < 0 ? ZOOM_IN_F : ZOOM_OUT_F;

  state.zoom *= factor;
  state.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, state.zoom));
  applyZoom();
}, { passive: false });

/* Mode switching */
modeRadios.forEach(radio => {
  radio.addEventListener("change", () => {
    if (!radio.checked) return;
    state.selectionMode = radio.value;
    if (state.selectionMode === MODE_FREE) hideTooltip();
  });
});

/* Theme switching */
themeRadios.forEach(radio => {
  radio.addEventListener("change", () => {
    if (!radio.checked) return;
    setTheme(radio.value);
  });
});

/* Build/reset */
buildBtn.addEventListener("click", () => {
  hideTooltip();
  buildGrid();
});

/* Undo/Redo buttons */
undoBtn.addEventListener("click", undo);
redoBtn.addEventListener("click", redo);

/* Keyboard shortcuts: Ctrl/Cmd+Z, Ctrl+Y, Ctrl+Shift+Z */
document.addEventListener("keydown", (event) => {
  const ctrlOrCmd = event.ctrlKey || event.metaKey;
  if (!ctrlOrCmd) return;

  const key = event.key.toLowerCase();

  if (key === "z") {
    event.preventDefault();
    if (event.shiftKey) {
      redo();
    } else {
      undo();
    }
  } else if (key === "y") {
    event.preventDefault();
    redo();
  }
});

/* =====================================================================
   INITIALISATION
   ===================================================================== */

setTheme("dark");
buildGrid();
applyZoom();

</script>

</body>
</html>
