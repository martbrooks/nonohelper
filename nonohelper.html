<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Nonogram Scratchpad</title>

<style>
  :root {
    --cell-size: 22px;
    --grid-font: system-ui, -apple-system, "Segoe UI", sans-serif;
  }

  body {
    font-family: var(--grid-font);
    max-width: 1000px;
    margin: 20px auto;
    padding: 0 16px 40px;
  }

  h1 {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
  }

  /* Controls */

  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
    margin-bottom: 8px;
  }

  .controls label {
    font-size: 0.95rem;
  }

  .controls input[type="number"] {
    width: 70px;
    padding: 3px 6px;
  }

  button {
    padding: 6px 12px;
    border-radius: 6px;
    border: 1px solid #ccc;
    background: #f4f4f4;
    cursor: pointer;
    font-size: 0.95rem;
  }

  button:hover {
    filter: brightness(1.05);
  }

  .mode-select {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-bottom: 16px;
    font-size: 0.9rem;
  }

  .mode-select label {
    cursor: pointer;
  }

  /* Board structure */

  .board-wrapper {
    overflow: visible;
    max-height: none;
  }

  .board {
    display: flex;
    flex-direction: column;
    gap: 4px;
    user-select: none;
    transform-origin: top left;
  }

  .top-row,
  .bottom-row {
    display: flex;
    align-items: flex-start;
    gap: 4px;
  }

  .middle-row {
    display: flex;
    align-items: flex-start;
    gap: 4px;
  }

  .corner {
    width: var(--cell-size);
    height: var(--cell-size);
  }

  .number-row {
    display: grid;
  }

  .number-col {
    display: grid;
  }

  .number-row > div,
  .number-col > div {
    font-size: 12px;
    text-align: center;
    color: #444;
    line-height: var(--cell-size);
    width: var(--cell-size);
    height: var(--cell-size);
  }

  .grid {
    display: grid;
  }

  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    box-sizing: border-box;
    border: 1px solid #ccc;
    background: #fff;
    font-size: 16px;
    line-height: var(--cell-size);
    text-align: center;
    cursor: pointer;
  }

  .cell.filled {
    background: #000;
    color: #000;
  }

  .cell.cross {
    background: #fff;
    color: #c00;
  }

  /* Tooltip showing selection dimensions */

  .selection-tooltip {
    position: fixed;
    padding: 2px 6px;
    font-size: 11px;
    background: rgba(0, 0, 0, 0.8);
    color: #fff;
    border-radius: 4px;
    pointer-events: none;
    z-index: 1000;
    display: none;
  }
</style>
</head>
<body>

<h1>Nonogram Scratchpad</h1>

<div class="controls">
  <label>
    Columns (width):
    <input type="number" id="colsInput" min="5" max="50" step="5" value="25">
  </label>
  <label>
    Rows (height):
    <input type="number" id="rowsInput" min="5" max="50" step="5" value="25">
  </label>
  <button id="buildGridBtn">Create / reset grid</button>
</div>

<div class="mode-select">
  <span>Selection mode:</span>
  <label><input type="radio" name="mode" value="line" checked> Straight line</label>
  <label><input type="radio" name="mode" value="rect"> Rectangle</label>
  <label><input type="radio" name="mode" value="free"> Freestyle</label>
</div>

<div class="board-wrapper" id="boardWrapper">
  <div class="board" id="boardRoot">

    <div class="top-row">
      <div class="corner"></div>
      <div id="topNums" class="number-row"></div>
      <div class="corner"></div>
    </div>

    <div class="middle-row">
      <div id="leftNums" class="number-col"></div>
      <div id="grid" class="grid"></div>
      <div id="rightNums" class="number-col"></div>
    </div>

    <div class="bottom-row">
      <div class="corner"></div>
      <div id="bottomNums" class="number-row"></div>
      <div class="corner"></div>
    </div>

  </div>
</div>

<script>
  // === Config ===

  const MIN_SIZE = 5;
  const MAX_SIZE = 50;
  const STEP_SIZE = 5;
  const MIN_ZOOM = 0.4;
  const MAX_ZOOM = 3.0;
  const ZOOM_IN_FACTOR = 1.1;
  const ZOOM_OUT_FACTOR = 0.9;

  // === DOM references ===

  const gridElement   = document.getElementById("grid");
  const colsInput     = document.getElementById("colsInput");
  const rowsInput     = document.getElementById("rowsInput");
  const buildGridBtn  = document.getElementById("buildGridBtn");

  const topNums    = document.getElementById("topNums");
  const bottomNums = document.getElementById("bottomNums");
  const leftNums   = document.getElementById("leftNums");
  const rightNums  = document.getElementById("rightNums");

  const boardRoot    = document.getElementById("boardRoot");
  const boardWrapper = document.getElementById("boardWrapper");

  const tooltip = document.createElement("div");
  tooltip.className = "selection-tooltip";
  document.body.appendChild(tooltip);

  // === State ===

  const state = {
    selectionMode: "line",  // "line" | "rect" | "free"
    isMouseDown: false,
    dragStartRow: null,
    dragStartCol: null,
    dragButton: null,       // 0 = left, 2 = right
    dragTargetState: null,  // "empty" | "filled" | "cross"
    cols: 25,
    rows: 25,
    originalStates: null,   // snapshot for line/rect
    zoom: 1
  };

  // === Utility functions ===

  function normaliseDimension(value) {
    let n = parseInt(value, 10);
    if (isNaN(n)) n = 25;
    n = Math.max(MIN_SIZE, Math.min(MAX_SIZE, n));
    n = Math.round(n / STEP_SIZE) * STEP_SIZE;
    return n;
  }

  function getCellState(cell) {
    return cell.dataset.state || "empty";
  }

  function setCellState(cell, newState) {
    cell.dataset.state = newState;
    cell.classList.remove("filled", "cross");
    cell.textContent = "";

    if (newState === "filled") {
      cell.classList.add("filled");
    } else if (newState === "cross") {
      cell.classList.add("cross");
      cell.textContent = "Ã—";
    }
  }

  function nextStateLeftClick(current) {
    if (current === "empty") return "filled";
    if (current === "filled") return "cross";
    return "empty";
  }

  function nextStateRightClick(current) {
    if (current === "empty") return "cross";
    if (current === "cross") return "filled";
    return "empty";
  }

  function indexFromRowCol(row, col) {
    return row * state.cols + col;
  }

  function snapshotGrid() {
    state.originalStates = Array.from(gridElement.children, cell => cell.dataset.state || "empty");
  }

  function restoreGridFromSnapshot() {
    if (!state.originalStates) return;
    const cells = gridElement.children;
    for (let i = 0; i < state.originalStates.length; i++) {
      setCellState(cells[i], state.originalStates[i]);
    }
  }

  // === Tooltip ===

  function showTooltip(text, x, y) {
    tooltip.textContent = text;
    tooltip.style.left = (x + 12) + "px";
    tooltip.style.top = (y + 12) + "px";
    tooltip.style.display = "block";
  }

  function hideTooltip() {
    tooltip.style.display = "none";
  }

  // === Zoom ===

  function applyZoom() {
    boardRoot.style.transform = `scale(${state.zoom})`;
  }

  function handleZoomWheel(event) {
    const isZoomGesture = event.ctrlKey || event.metaKey;
    if (!isZoomGesture) return;

    event.preventDefault();

    const delta = event.deltaY || 0;
    const factor = delta < 0 ? ZOOM_IN_FACTOR : ZOOM_OUT_FACTOR;

    state.zoom *= factor;
    state.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, state.zoom));

    applyZoom();
  }

  // === Grid building ===

  function buildNumberRow(container, count) {
    container.innerHTML = "";
    container.style.gridTemplateColumns = `repeat(${count}, var(--cell-size))`;
    for (let i = 1; i <= count; i++) {
      const cell = document.createElement("div");
      cell.textContent = i;
      container.appendChild(cell);
    }
  }

  function buildNumberCol(container, count) {
    container.innerHTML = "";
    container.style.gridTemplateRows = `repeat(${count}, var(--cell-size))`;
    for (let i = 1; i <= count; i++) {
      const cell = document.createElement("div");
      cell.textContent = i;
      container.appendChild(cell);
    }
  }

  function buildGrid() {
    const cols = normaliseDimension(colsInput.value);
    const rows = normaliseDimension(rowsInput.value);

    // Persist normalised values
    colsInput.value = cols;
    rowsInput.value = rows;
    state.cols = cols;
    state.rows = rows;

    // Numbering
    buildNumberRow(topNums, cols);
    buildNumberRow(bottomNums, cols);
    buildNumberCol(leftNums, rows);
    buildNumberCol(rightNums, rows);

    // Main grid
    gridElement.innerHTML = "";
    gridElement.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.state = "empty";
        cell.dataset.row = String(r);
        cell.dataset.col = String(c);

        // Border widths for 5x5 blocks and outer edge
        const topWidth =
          r === 0 ? 3 :
          r % 5 === 0 ? 2 : 1;
        const leftWidth =
          c === 0 ? 3 :
          c % 5 === 0 ? 2 : 1;
        const bottomWidth =
          r === rows - 1 ? 3 :
          (r + 1) % 5 === 0 ? 2 : 1;
        const rightWidth =
          c === cols - 1 ? 3 :
          (c + 1) % 5 === 0 ? 2 : 1;

        cell.style.borderTopWidth = topWidth + "px";
        cell.style.borderLeftWidth = leftWidth + "px";
        cell.style.borderBottomWidth = bottomWidth + "px";
        cell.style.borderRightWidth = rightWidth + "px";

        cell.addEventListener("mousedown", onCellMouseDown);
        cell.addEventListener("mouseenter", onCellMouseEnter);

        gridElement.appendChild(cell);
      }
    }
  }

  // === Drawing helpers ===

  function drawLineTo(row, col) {
    const dr = row - state.dragStartRow;
    const dc = col - state.dragStartCol;

    if (Math.abs(dr) >= Math.abs(dc)) {
      // Vertical line
      const r1 = Math.min(state.dragStartRow, row);
      const r2 = Math.max(state.dragStartRow, row);
      for (let r = r1; r <= r2; r++) {
        const idx = indexFromRowCol(r, state.dragStartCol);
        setCellState(gridElement.children[idx], state.dragTargetState);
      }
    } else {
      // Horizontal line
      const c1 = Math.min(state.dragStartCol, col);
      const c2 = Math.max(state.dragStartCol, col);
      for (let c = c1; c <= c2; c++) {
        const idx = indexFromRowCol(state.dragStartRow, c);
        setCellState(gridElement.children[idx], state.dragTargetState);
      }
    }
  }

  function drawRectTo(row, col) {
    const r1 = Math.min(state.dragStartRow, row);
    const r2 = Math.max(state.dragStartRow, row);
    const c1 = Math.min(state.dragStartCol, col);
    const c2 = Math.max(state.dragStartCol, col);

    for (let r = r1; r <= r2; r++) {
      for (let c = c1; c <= c2; c++) {
        const idx = indexFromRowCol(r, c);
        setCellState(gridElement.children[idx], state.dragTargetState);
      }
    }
  }

  // === Event handlers: cells ===

  function onCellMouseDown(event) {
    if (event.button !== 0 && event.button !== 2) return; // left / right only

    event.preventDefault();
    hideTooltip();

    const cell = event.currentTarget;
    const row = Number(cell.dataset.row);
    const col = Number(cell.dataset.col);

    const current = getCellState(cell);
    const next = event.button === 0
      ? nextStateLeftClick(current)
      : nextStateRightClick(current);

    setCellState(cell, next);

    state.isMouseDown = true;
    state.dragButton = event.button;
    state.dragStartRow = row;
    state.dragStartCol = col;
    state.dragTargetState = next;

    if (state.selectionMode === "free") {
      state.originalStates = null;
      return;
    }

    snapshotGrid();
    showTooltip("1x1", event.clientX, event.clientY);
  }

  function onCellMouseEnter(event) {
    if (!state.isMouseDown) return;

    const cell = event.currentTarget;
    const row = Number(cell.dataset.row);
    const col = Number(cell.dataset.col);

    if (state.selectionMode === "free") {
      const cur = getCellState(cell);
      const next = state.dragButton === 0
        ? nextStateLeftClick(cur)
        : nextStateRightClick(cur);
      setCellState(cell, next);
      return;
    }

    // line / rect: restore then redraw current selection
    restoreGridFromSnapshot();
    if (state.selectionMode === "line") {
      drawLineTo(row, col);
    } else if (state.selectionMode === "rect") {
      drawRectTo(row, col);
    }
  }

  // === Event handlers: dimension tooltip ===

  gridElement.addEventListener("mousemove", (event) => {
    if (!state.isMouseDown || state.selectionMode === "free") {
      hideTooltip();
      return;
    }

    const cell = event.target.closest(".cell");
    if (!cell) return;

    const row = Number(cell.dataset.row);
    const col = Number(cell.dataset.col);

    let width  = Math.abs(col - state.dragStartCol) + 1;
    let height = Math.abs(row - state.dragStartRow) + 1;

    if (state.selectionMode === "line") {
      const dr = row - state.dragStartRow;
      const dc = col - state.dragStartCol;
      if (Math.abs(dr) >= Math.abs(dc)) {
        // vertical line
        width = 1;
        height = Math.abs(dr) + 1;
      } else {
        // horizontal line
        width = Math.abs(dc) + 1;
        height = 1;
      }
    }

    showTooltip(`${width}x${height}`, event.clientX, event.clientY);
  });

  // === Global handlers ===

  document.addEventListener("mouseup", () => {
    state.isMouseDown = false;
    state.dragStartRow = null;
    state.dragStartCol = null;
    state.dragButton = null;
    state.dragTargetState = null;
    state.originalStates = null;
    hideTooltip();
  });

  gridElement.addEventListener("contextmenu", (event) => {
    event.preventDefault();
  });

  // Zoom: Ctrl (Win/Linux) or Command (macOS) + wheel
  boardWrapper.addEventListener("wheel", handleZoomWheel, { passive: false });

  // Mode selector
  document.querySelectorAll('input[name="mode"]').forEach(radio => {
    radio.addEventListener("change", () => {
      if (!radio.checked) return;
      state.selectionMode = radio.value;
      if (state.selectionMode === "free") hideTooltip();
    });
  });

  // Create / reset grid button
  buildGridBtn.addEventListener("click", () => {
    hideTooltip();
    buildGrid();
  });

  // === Initialisation ===

  buildGrid();
  applyZoom();
</script>

</body>
</html>
